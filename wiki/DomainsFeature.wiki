#summary Our ideas about implementing data domains
#labels Phase-Requirements

The Architect currently does not support the concept of data domains, but it's a feature we have been planning to add for some time.


==Motivation==

  # Provide a way of using every native type in all target databases without requiring a commitment to a single target platform up front
  # Provide the means to create a more compelling logical model by allowing the use of logical types
    * This also makes it possible to produce simplified diagrams for reporting users where types are boiled down to "text," "number," "date/time," and "boolean."
  # Pave the way for an "enterprise metadata repository" that will enhance the rest of our product suite when used against a database on which logical types have been defined (either because the model was created in Architect, or the domains were "retrofitted" over an existing model).


==Implementation Considerations==

  # Don't compromise Architect's unique feature of platform-independent modeling
  # Must preserve forward compatibility for existing .architect project files
  # Think about how this new feature might interact with, enhance, or be enhanced by the Architect's existing feature set:
    * Forward Engineering
    * Reverse Engineering
    * Profiling
    * Compare DM
    * Column properties editor
    * Playpen display preferences
    * Print/PDF
    * HTML data model report
    * OLAP modeling

==Proposed Features==

  * Domains would appear wherever data types are currently used
  * Add a project setting to choose between displaying Domains and physical types for a particular database platform
  * Be able to specify domains for columns of existing database tables
  * GUI facility for defining new domains, capturing:
    * Logical type name
    * "Basic" or fundamental type: text, number, boolean, date/time, and complex/other
    * Physical type in each target database you care about, including precision and scale plus custom native-coded check constraints (can be deferred until forward engineering time if desired)
    * Constraints on value
    * Default value
    * Display preferences (number/date format, alignment, display width)
    * Description/documentation of purpose and correct usage
    * Preferred aggregation function
  * TODO: Need to consider how reverse engineering will work

==Optional Features==

  * Include an example library of semantic types that people could start with
  * Ability to define a hierarchy of domain types (such as a Monetary base class which would then have CAD, USD, and so on)
  * A more structured way to define enumerated types that forward engineer as ENUM or varchar with check constraints depending on target platform support and idioms
  * Ability to "extract" the domains from a project file so that they can be used in another project